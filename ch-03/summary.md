# 3장 | 함수

## 💻 작게 만들어라

> "함수를 만드는 첫째 규칙은 '작게!'다. 함수를 만드는 둘째 규칙은 '더 작게!'다." (p.42)

* 조건문에 들어가는 블록은 한 줄이어야 한다.

## 💻 한 가지만 해라

> "함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다." (p.44)

* 저장된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행해야 한다.
* 의미 있는 다른 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하고 있는 것이다.

## 💻 함수 당 추상화 수준은 하나로

> "... 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다." (p.46)

* 추상화 수준을 섞으면 표현이 근본 개념인지 세부사항인지 구분하기 어려워 헷갈리게 된다.

#### 내려가기 규칙
* 위에서 아래로 이야기처럼 읽혀야 좋다.
* 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.

## 💻 Switch 문

* 장황한 switch 문의 반복은 추상 팩토리 & 다형성 객체 생성 코드로 개선할 수 있다.<br>
예) 목록 3-5. Employee and Factory

## 💻 서술적인 이름을 사용하라

> "코드를 읽으면서 짐작했던 기능을 각 루닡이 그대로 수행한다면 깨끗한 코드라 불러도 되겠다." (p.49)

* 함수가 작고 단순하며, 하는 일을 잘 표현해야 한다.

## 💻 함수 인수

> "이상적인 인수 개수는 0개(무항)다. 다음은 1개(단항)고, 다음은 2개(이항)다." (p.50)

* 인수는 개념을 이해하기 어렵게 만든다.
* 별로 중요하지 않은 세부사항임에도 불구하고, 발견할 때마다 의미를 해석해야 하기 때문이다.
* 인수가 생기면 모든 경우의 수를 검증하는 테스트 케이스를 작성하기 복잡해진다.

#### 인수를 없애는/줄이는 방법
* 인수를 현재 클래스 static 변수로 만들어 인수로 넘기지 않는다.
* 별도의 클래스를 작성하여 인수를 생성자로 받아 그 클래스의 static 변수로 만들고 클래스 내에서 메소드를 구현한다.
* 인수 클래스에 메소드를 추가하고 기존 클래스에서 객체.메소드 형태로 호출한다.
* 인수가 2-3개 필요하다면, 인수를 독자적인 클래스 변수로 선언한다.

#### 단항 함수가 적절한 경우
* 인수에 질문을 던지는 경우<br>
예) `boolean fileExists("MyFile")`
* 인수를 뭔가로 변환해 결과로 반환하는 경우<br>
예) `InputStream fileOpen("MyFile")`
* 이벤트 (입력 인수로 시스템 상태를 바꾸는 경우)<br>
예) `void passwordAttemptFailedNtimes(int attempts)`

#### 이항 함수가 적절한 경우
* 인수 2개가 한 값을 표현하고, 자연적인 순서가 있는 경우<br>
좋은 예) `Point p = new Point(0,0)`<br>
나쁜 예) `assertEquals(expected, actual)`

#### 삼항 함수가 적절한 경우
* 부동소수점 비교<br>
예) `assertEquals(1.0, amount, .001)`

#### 플래그 인수는 금지
* 각 플래그 값에 따라 별도의 함수를 작성하라.<br>
예) `render(boolean isSuite)` → `renderForSuite()` & `renderForSingleTest()`

#### 가변 인수
* 인수 개수가 가변적인 경우<br>
예) `String.format("%s worked %.2f hours.", name, hours);`

#### 동사와 키워드
* 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다.<br>
예) `write(name)`
* 함수 이름에 인수에 관한 키워드를 추가하라.<br>
예) `write(name)` → `writeField(name)`<br>
예) `assertEquals()` → `assertExpectedEqualsActual(expected, actual)`

## 💻 부수 효과를 일으키지 마라

* 예상치 못한 부수 효과는 시간적인 결합, 순서 종속성을 초래하게 된다.

## 💻 명령과 조회를 분리하라

* 함수는 뭔가를 수행하거나, 뭔가에 답하거나 둘 중 하나만 해야 한다.<br>
나쁜 예)
```java
if (set("username", "myname"))
  ...
```
좋은 예)
```java
if (attributeExists("username")) {
  setAttribute("username", "myname");
  ...
}
```

## 💻 오류 코드보다 예외를 사용하라

* 오류 코드를 반환하는 방식은 여러 단계로 중첩되는 코드를 야기한다.
* 오류 코드를 반환하는 방식은 오류 코드를 곧바로 처리해야 한다는 문제가 발생한다.
* 오류 코드를 정의하는 의존성 자석(magnet)은 재컴파일/재배치를 요구하기 때문에 번거로워진다.

#### Try/Catch 블록
* `Try/Catch` 블록을 별도 함수로 뽑아내고, `try`문 안에서 실제 '작업' 메소드를 호출한다.
* 실제 '작업'을 하는 코드에서는 `thorws Exception`하여 모든 예외 처리를 한 곳에서 처리한다.

## 💻 반복하지 마라

> "어쩌면 중복은 소프트웨어에서 모든 악의 근원이다." (p.60)

* 코드 길이가 늘어난다.
* 알고리즘이 변하면 중복된 코드 모두 수정해야 한다.
* 오류가 발생할 확률도 몇 배로 높다.



